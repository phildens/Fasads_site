{% extends "base.html" %}
{% load static %}

{% block title %}{% if category_slug and category_slug != "all" %}Каталог — {{ category_slug|title }}{% else %}Каталог
{% endif %}{% endblock %}

{% block extra_css %}
    <style>
        .pagination button {
            padding: 10px 18px;
            margin: 0 6px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            font-family: Montserrat;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .page {
            max-width: 1180px;
            margin: 0 auto;
            padding: 24px 16px 64px;
            font-family: Montserrat, Arial, sans-serif;
            box-sizing: border-box
        }

        .crumbs {
            margin-bottom: 18px;
            margin-top: 33px;

            font-family: Montserrat;
            font-weight: 400;
            font-size: 16px;
            color: #000000;
        }

        .crumbs a {
            color: inherit;
            text-decoration: none;

        }

        .head-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0 18px
        }

        .title {
            font-family: Montserrat;
            font-weight: 500;
            font-size: 48px;
            letter-spacing: 0;
            line-height: 100%;
            margin: 0;
            color: #422223
        }

        .sort {
            font-size: 13px;
        {#color: #6a5f5e; #} display: flex;
            gap: 8px;
            align-items: center
        }

        @media (max-width: 500px) {
            .sort {
                display: none;
            }
        }

        .sort select {
            border: none;
            background: none;
            border-radius: 8px;
            padding: 8px 12px;
            outline: none
        }

        .layout {
            margin-top: 67px;
            display: grid;
            grid-template-columns:350px 1fr;
            gap: 24px
        }

        @media (max-width: 960px) {
            .layout {
                grid-template-columns:1fr
            }
        }

        /* Сайдбар фильтров */
        .filters {
        {#position: sticky;#} top: 12px;
            height: max-content
        }

        @media (max-width: 960px) {
            .filters {
                position: static;
                top: auto;
                margin-bottom: 12px
            }
        }

        .filter-accordion {
            font-weight: 500;
            font-family: Montserrat;
            font-size: 20px;
            line-height: 100%;
            letter-spacing: 0;
            overflow: hidden;
            background: none;
        }

        .filter-item + .filter-item {
            border-top: 1px solid #D9D9D9
        }

        .filter-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 28px 5px;
            cursor: pointer;
            user-select: none
        }

        .filter-head h4 {
            margin: 0;
            color: #422223;
            font-family: Montserrat;
            font-weight: 500;
            font-size: 20px;
            line-height: 100%;
            letter-spacing: 0;

        }

        .chev {
            transition: transform .2s ease
        }

        /* Без внутренних скроллов: просто скрываем/показываем */
        .filter-content {
            display: none;
            padding: 4px 0 10px
        }

        .filter-item.open .filter-content {
            display: block
        }

        .filter-item.open .chev {
            transform: rotate(180deg)
        }

        .opt {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px
        }

        .opt input {
            width: 16px;
            height: 16px
        }

        .actions {
            margin-top: 12px;
            display: flex;
            gap: 10px
        }

        .btn {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 12px 14px;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer
        }

        .btn-primary {
            background: #e7e5e3;
            border: none;
            width: 350px;
            font-family: Montserrat;
        }

        .btn-dark {
            background: #2b1b2a;
            color: #fff
        }

        .btn:disabled {
            opacity: .6;
            cursor: not-allowed
        }

        .grid {
            display: grid;
            grid-template-columns:repeat(2, 1fr);
            gap: 24px
        }

        @media (max-width: 1100px) {
            .grid {
                grid-template-columns:repeat(2, 1fr)
            }
        }

        @media (max-width: 640px) {
            .grid {
                grid-template-columns:1fr
            }
        }

        .card {
            background: #fff;
            border: 1px solid #eee;
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column
        }

        .img-wrap {
            position: relative;
            background: #f6f4f3
        }

        .img-wrap img {
            width: 100%;
            height: 250px;
            object-fit: cover;
            border-radius: 10px;
            display: block
        }

        .badge {
            display: flex;
            position: absolute;
            left: 36px;
            width: 147px;
            top: 27px;
            background: #3A8F03;
            color: #fff;
            padding: 15px 20px;
            font-family: Montserrat;
            font-weight: 400;
            line-height: 100%;
            letter-spacing: 0;
            border-radius: 10px;
            font-size: 16px
        }

        .badge p {
            position: absolute;
            left: 53px;
            top: 20px;

        }

        .badge img {
            width: 24px;
            height: 24px;
        }

        .body {
            padding: 16px;
            padding-left: 39px;
        }

        .name {
            margin: 0 0 10px;
            margin-bottom: 25px;
            margin-top: 53px;
            font-family: Montserrat;
            font-weight: 600;
            font-size: 28px;
            line-height: 100%;
            letter-spacing: 0;
            color: #422223;

        }

        .price-link {
            font-size: 13px;
            color: #422223;
            text-decoration: underline
        }

        .price-link {
            font-size: 20px;
            font-family: Montserrat;
            font-weight: 400;
            color: #422223;
            text-decoration: underline;
        }

        .foot {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 12px 16px;
            margin-right: 20px;
            margin-bottom: 15px;


        }

        .icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            border: none;
            background: #efefef;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer
        }

        .heart {
            background-color: #422223;
            width: 56px;
            height: 47px;
        }

        .tg-ico {
            background-color: #3A8F03;
            width: 56px;
            height: 47px;
        }

        .tg-ico img {
            height: 25px;
        }

        /* чтобы на кнопку можно было положить псевдоэлемент-линейку */
        .icon-btn.heart {
            position: relative;
        }

        /* когда товар в избранном → перечёркиваем сердце */
        .icon-btn.heart[aria-pressed="true"]::after,
        .icon-btn.heart.is-fav::after { /* .is-fav — запасной класс, если удобнее так */
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            width: 36px; /* длина штриха */
            height: 2px; /* толщина штриха */
            background: #fff; /* цвет штриха поверх тёмной кнопки */
            border-radius: 2px;
            transform: translate(-50%, -50%) rotate(-35deg);
            pointer-events: none; /* чтобы клик ловила кнопка, а не линия */
        }

        .empty {
            padding: 48px 0;
            text-align: center;
            color: #7b6a68
        }

        .skeleton {
            animation: pulse 1.2s ease-in-out infinite;
            background: linear-gradient(90deg, #eee 25%, #f5f5f5 37%, #eee 63%);
            background-size: 400% 100%
        }

        @keyframes pulse {
            0% {
                background-position: 100% 0
            }
            100% {
                background-position: 0 0
            }
        }

        .s-card {
            border-radius: 16px;
            border: 1px solid #eee;
            overflow: hidden
        }

        .s-img {
            height: 220px
        }

        .card a {
            color: #422223;
            text-decoration: none
        }

        .card a:hover {
            text-decoration: none
        }

        .s-line {
            height: 18px;
            margin: 12px 16px;
            border-radius: 6px
        }

        .price-link {
            margin-top: 25px;
            font-size: 20px;
            font-family: Montserrat;
            font-weight: 400;
            color: #422223;
            text-decoration: underline !important;
            justify-self: end;
        }

        /* Базовый стиль — дизайн без изменений, только цвет через переменные */
        .badge {
            background: var(--badge-bg, #3A8F03);
            color: var(--badge-fg, #fff);
        }

        /* чтобы текст точно подхватывал цвет */
        .badge p {
            color: inherit;
        }

        /* Модификаторы “метки” */
        .badge--favorite {
            --badge-bg: #3A8F03; /* зелёный */
            --badge-fg: #ffffff;
        }

        .badge--sale {
            --badge-bg: #FF3B30; /* красный */
            --badge-fg: #ffffff;
        }

        .badge--new {
            --badge-bg: #ffffff; /* белый фон */
            --badge-fg: #111111; /* чёрный текст */
            border: 1px solid rgba(0, 0, 0, .08); /* тонкий бордер, дизайн как был */
        }

        /* --- SEARCH MODE (без фильтров) --- */
        .page.search-mode .layout {
            grid-template-columns: 1fr;
        }

        /* убираем пустую левую колонку */
        .page.search-mode .filters {
            display: none !important;
        }

        /* прячем панель */

        @media (min-width: 1100px) {
            .page.search-mode .grid {
                grid-template-columns: repeat(3, 1fr);
            }

            /* 3 карточки в ряд на широком экране */
        }

        /* чтобы кнопки внизу карточки всегда были на одном уровне */
        .card {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .body {
            flex: 1 1 auto;
        }

        /* тело карточки растягивается, .foot уезжает вниз */
        .pagination {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }

        .pagination .page-btn {
            min-width: 38px;
            height: 38px;
            padding: 0 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #D9D9D9;
            border-radius: 10px;
            background: #fff;
            font-family: Montserrat;
            font-size: 14px;
            color: #422223;
            text-decoration: none;
            cursor: pointer;
        }

        .pagination .page-btn[aria-current="page"] {
            background: #2b1b2a;
            color: #fff;
            border-color: #2b1b2a;
            cursor: default;
        }

        .pagination .page-btn:disabled {
            opacity: .5;
            cursor: not-allowed;
        }

        .pagination .dots {
            padding: 0 6px;
            color: #7b6a68;
        }

        .infinite-wrap {
            margin: 24px auto 64px;
            text-align: center;
        }

        #loadMore {
            padding: 10px 18px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            font-family: Montserrat;
        }

        .spinner {
            width: 24px;
            height: 24px;
            margin: 12px auto;
            border: 2px solid #ddd;
            border-top-color: #555;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .sentinel {
            height: 1px;
        }

        /* базовые размеры иконки (как у тебя) */
        .badge__icon {
            width: 24px;
            height: 24px;
            display: block;
        }

        /* только для новинки: делаем чёрной */
        .badge--new .badge__icon {
            filter: brightness(0); /* превращает белую в чёрную */
        }

        /* на всякий случай фиксируем отсутствие фильтра у остальных */
        .badge--favorite .badge__icon,
        .badge--sale .badge__icon {
            filter: none;
        }


    </style>
{% endblock %}

{% block content %}
    <div id="catalog"
         class="page"
         data-cat-slug="{{ category_slug }}"
         data-endpoint-category-cat="/api/categories/{slug}/"
         data-endpoint-products-cat="/api/categories/{slug}/products/"
         data-endpoint-filters-cat="/api/categories/{slug}/filters/"
         data-endpoint-products-all="/api/catalog/"
         data-endpoint-filters-all="/api/filters/"
         data-endpoint-search-products="/api/categories/search/products/">


        <div class="crumbs">
            <a href="/">Главная</a> ›
            <span id="crumb-cat">{% if category_slug and category_slug != "all" %}{{ category_slug|title }}{% else %}
                Каталог{% endif %}</span>
        </div>

        <div class="head-row">
            <h1 class="title" id="title-cat">
                {% if category_slug and category_slug != "all" %}{{ category_slug|title }}{% else %}
                    Каталог{% endif %}</h1>
            <div class="sort">
                <span>по</span>
                <select id="sort">
                    <option value="default">умолчанию</option>
                    <option value="name_asc">названию (А–Я)</option>
                    <option value="name_desc">названию (Я–А)</option>
                </select>
            </div>
        </div>
        <div style="height: 1px; max-width: 1148px; background-color: black"></div>

        <div class="layout">
            <aside class="filters">
                <div id="filters" class="filter-accordion"></div>
                <div class="actions">
                    <button id="apply" class="btn btn-dark" disabled style="display: none">Применить фильтры</button>
                    <button id="reset" class="btn btn-primary">Сбросить</button>
                </div>
            </aside>
            <main>
                <div id="grid" class="grid"></div>
                <!-- Подгрузка для режима поиска -->
                <div id="infiniteWrap" class="infinite-wrap" style="display:none">
                    <button id="loadMore" class="btn-outline" type="button">Показать ещё</button>
                    <div id="loadSpinner" class="spinner" aria-hidden="true" style="display:none"></div>
                    <!-- Невидимый «маяк» для автоподгрузки у низа страницы -->
                    <div id="loadSentinel" class="sentinel" aria-hidden="true"></div>
                </div>

                <div id="empty" class="empty" style="display:none">Ничего не найдено</div>
                <div id="pagination" class="pagination" style="margin-top:32px;"></div>

                <!-- Навигация по страницам -->

            </main>

        </div>

    </div>
{% endblock %}

{% block extra_js %}
    <script>
        const $pagination = document.getElementById("pagination");

        function getPageParam() {
            const p = new URLSearchParams(location.search);
            const n = parseInt(p.get("page") || "1", 10);
            return Number.isFinite(n) && n > 0 ? n : 1;
        }

        function buildUrlWithPage(page) {
            const p = new URLSearchParams(location.search);
            if (page > 1) p.set("page", String(page)); else p.delete("page");
            return location.pathname + "?" + p.toString();
        }

        function renderSearchPagination(meta) {
            // показываем пагинацию только для поиска и только если страниц > 1
            if (!isSearch || !meta || !meta.pages || meta.pages <= 1) {
                $pagination.innerHTML = "";
                return;
            }
            const cur = +meta.page || 1;
            const total = +meta.pages || 1;

            const parts = [];
            // назад
            if (meta.has_prev) {
                parts.push(`<a class="page-btn" href="${buildUrlWithPage(cur - 1)}">Назад</a>`);
            }
            // окно номеров: 1 … [cur-2 cur-1 cur cur+1 cur+2] … total
            const span = 2;
            const from = Math.max(1, cur - span);
            const to = Math.min(total, cur + span);

            if (from > 1) {
                parts.push(`<a class="page-btn" href="${buildUrlWithPage(1)}">1</a>`);
                if (from > 2) parts.push(`<span class="dots">…</span>`);
            }
            for (let i = from; i <= to; i++) {
                if (i === cur) parts.push(`<a class="page-btn" aria-current="page">${i}</a>`);
                else parts.push(`<a class="page-btn" href="${buildUrlWithPage(i)}">${i}</a>`);
            }
            if (to < total) {
                if (to < total - 1) parts.push(`<span class="dots">…</span>`);
                parts.push(`<a class="page-btn" href="${buildUrlWithPage(total)}">${total}</a>`);
            }
            // вперёд
            if (meta.has_next) {
                parts.push(`<a class="page-btn" href="${buildUrlWithPage(cur + 1)}">Вперёд</a>`);
            }

            $pagination.innerHTML = parts.join("");

            // необязательно: перехватываем клики, чтобы не перезагружать страницу целиком
            // и просто менять параметр и перерисовывать список
            $pagination.querySelectorAll(".page-btn[href]").forEach(a => {
                a.addEventListener("click", (e) => {
                    e.preventDefault();
                    const url = new URL(a.getAttribute("href"), location.origin);
                    // применим новый page в адресной строке и перерисуем
                    history.replaceState({}, "", url.pathname + url.search);
                    loadProducts(); // перерисовать текущую страницу
                    // и плавно прокрутить к началу сетки
                    document.getElementById("grid").scrollIntoView({behavior: "smooth", block: "start"});
                });
            });
        }


        (function () {
            const root = document.getElementById("catalog");
            const catSlug = (root.dataset.catSlug || "all").toString().trim();
            const apiSlug = (catSlug && catSlug !== "all") ? catSlug.toLowerCase() : "all";

            // endpoints
            const epCategoryCat = root.dataset.endpointCategoryCat;
            const epProductsCat = root.dataset.endpointProductsCat;
            const epFiltersCat = root.dataset.endpointFiltersCat;
            const epProductsAll = root.dataset.endpointProductsAll;
            const epFiltersAll = root.dataset.endpointFiltersAll;
            const epSearchProducts = root.dataset.endpointSearchProducts; // NEW
            const $loadWrap = document.getElementById("infiniteWrap");
            const $loadMore = document.getElementById("loadMore");
            const $spinner = document.getElementById("loadSpinner");
            const $sentinel = document.getElementById("loadSentinel");

            // локальный стейт пагинации для поиска
            const searchState = {
                page: 1,
                perPage: 12,
                hasNext: false,
                isLoading: false
            };
            const listState = {
                page: 1,
                perPage: 20,      // <-- 20 на страницу
                hasNext: false,
                isLoading: false
            };

            const $filters = document.getElementById("filters");
            const $grid = document.getElementById("grid");
            const $empty = document.getElementById("empty");
            const $apply = document.getElementById("apply");
            const $reset = document.getElementById("reset");
            const $sort = document.getElementById("sort");
            const $title = document.getElementById("title-cat");
            const $crumb = document.getElementById("crumb-cat");

            // режим поиска
            const q = getParam("q");
            const isSearch = !!q && !!epSearchProducts;

            if (isSearch) {
                // добавляем класс на корневой контейнер страницы,
                // чтобы сработали CSS-правила выше
                root.classList.add("search-mode");
            }
            // Человекочитаемые названия фильтров
            const FILTER_TITLES = {
                manufacturer: "Производитель",
                color: "Цвет",
                type_material: "Вид материала",
                product_type: "Категория товара", // было: "Тип товара"
                frosen_defend: "Морозостойкость",
                strength_grade: "Марка прочности",
                water_resistance: "Водопоглощение",
                format: "Формат",
                emptiness: "Пустотность"
            };
const CATEGORY_ORDER = [
  "облицовочный кирпич",
  "клинкерный кирпич",
  "кирпич ручной формовки",
  "ригельный кирпич",
  "навесные вентилируемые системы (НВФ)",
  "клинкерная плитка под НВФ",
  "плитка под кирпич",
  "брусчатка",
    "кровельные материалы",
  "керамические блоки",
  "смеси",
  "газоблок"
];
            // state
            const state = {
                sort: getParam("sort") || "default",
                filters: parseFilterParams(location.search),
                paramMap: {}
            };
            $sort.value = state.sort;

            // helpers
            function urlFor(tpl, slug) {
                return tpl.replace("{slug}", slug || "all");
            }

            function getParam(k) {
                return new URLSearchParams(location.search).get(k);
            }

            function parseFilterParams(qs) {
                const params = new URLSearchParams(qs);
                const obj = {};
                for (const [kRaw, v] of params.entries()) {
                    if (kRaw === "sort" || kRaw === "ordering" || kRaw === "q" || kRaw === "page") continue;
                    const k = kRaw.endsWith("[]") ? kRaw.slice(0, -2) : kRaw;
                    (obj[k] ||= []).push(v);
                }
                return obj;
            }

            function buildQuery(includeQ = false) {
                const p = new URLSearchParams();
                if (state.sort && state.sort !== "default") {
                    p.set("sort", state.sort);
                    p.set("ordering", state.sort === "name_asc" ? "name" : "-name");
                }
                Object.entries(state.filters).forEach(([k, arr]) => (arr || []).forEach(v => p.append(k, v)));
                if (includeQ && q) p.set("q", q);
                const s = p.toString();
                return s ? "?" + s : "";
            }

            function pushUrl() {
                // в режиме поиска обязательно сохраняем q
                history.replaceState({}, "", location.pathname + buildQuery(isSearch));
            }

            function toTitle(slug) {
                return (!slug || slug === "all") ? "Каталог" : slug.replace(/[-_]+/g, " ").replace(/\b\w/g, ch => ch.toUpperCase());
            }

            function escapeHtml(s) {
                return String(s).replace(/[&<>"']/g, m => ({
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    "\"": "&quot;",
                    "'": "&#39;"
                }[m]));
            }

            function escapeAttr(s) {
                return escapeHtml(s).replace(/"/g, "&quot;");
            }

            function debounce(fn, ms) {
                let t;
                return (...a) => {
                    clearTimeout(t);
                    t = setTimeout(() => fn(...a), ms);
                }
            }

            const applyFiltersDebounced = debounce(applyFiltersNow, 150);

            // -------- Нормализация --------
            function normalizeValues(val) {
                if (Array.isArray(val)) {
                    return val.map(v => {
                        if (typeof v === "object") {
                            const value = String(v.value ?? v.slug ?? v.id ?? "");
                            const label = String(v.label ?? v.title ?? v.name ?? value);
                            const count = (typeof v.count === "number") ? v.count : undefined;
                            return {value, label, count};
                        } else {
                            const s = String(v);
                            return {value: s, label: s};
                        }
                    });
                }
                if (val && typeof val === "object") {
                    return Object.entries(val).map(([vk, vc]) => ({
                        value: String(vk), label: String(vk),
                        count: (typeof vc === "number") ? vc : undefined
                    }));
                }
                return [];
            }

            function normalizeGroups(input) {
                if (!input) return [];
                if (Array.isArray(input)) return input;
                if (typeof input === "object") {
                    return Object.entries(input).map(([key, val]) => {
                        if (Array.isArray(val)) {
                            return {key, title: key, param: key, values: normalizeValues(val)};
                        }
                        if (val && typeof val === "object") {
                            const title = String(val.verbose_name ?? val.title ?? val.label ?? val.name ?? key);
                            const param = String(val.param ?? val.name ?? val.key ?? key);
                            const rawValues = val.values ?? val.options ?? val.items ?? val.choices ?? val;
                            return {key, title, param, values: normalizeValues(rawValues)};
                        }
                        return {key, title: key, param: key, values: []};
                    });
                }
                return [];
            }

            // UI
            function renderSkeletonCards(n = 6) {
                $grid.innerHTML = "";
                for (let i = 0; i < n; i++) {
                    const d = document.createElement("div");
                    d.className = "s-card";
                    d.innerHTML = `<div class="s-img skeleton"></div><div class="s-line skeleton" style="width:70%"></div><div class="s-line skeleton" style="width:40%"></div>`;
                    $grid.appendChild(d);
                }
            }

            function getProductUrl(item) {
                if (item?.link) return item.link;
                const id = item?.id ?? item?.pk;
                return (id != null) ? `/p/${encodeURIComponent(id)}/` : '#';
            }

            function appendCards(items) {
                if (!items || !items.length) return;
                const frag = document.createElement("div");
                frag.innerHTML = renderCardsToHtml(items); // используем ту же верстку
                // аккуратно добавим
                [...frag.children].forEach(node => $grid.appendChild(node));
                // уведомим менеджер избранного, если есть
                if (window.SFFavorites) document.dispatchEvent(new CustomEvent('sf:favs-changed'));
            }

// небольшая выносная функция, чтобы re-use разметки
            function renderCardsToHtml(items) {
                const normalizeTag = (val) => {
                    const raw = String(val || "").trim().toLowerCase();
                    const map = {
                        "favorite": "favorite",
                        "фаворит": "favorite",
                        "sale": "sale",
                        "акция": "sale",
                        "new": "new",
                        "новинка": "new"
                    };
                    return map[raw] || "";
                };
                const badgeMeta = {
                    favorite: {label: "фаворит", cls: "badge--favorite"},
                    sale: {label: "акция", cls: "badge--sale"},
                    new: {label: "новинка", cls: "badge--new"},
                };
                return items.map(card => {
                    const name = escapeHtml(card.name || "");
                    const img = escapeHtml(card.card_image || card.image || "");
                    const href = getProductUrl(card);
                    const id = card.id ?? card.pk;
                    const key = normalizeTag(card.promo_tag || card.badge);
                    const badge = key ? badgeMeta[key] : null;
                    return `
      <div class="card">
        <div class="img-wrap">
          ${img ? `<a href="${href}" aria-label="${name}" target="_blank"><img src="${img}" alt="${name}"></a>` : `<div class="s-img skeleton"></div>`}
          ${badge ? `
            <div class="badge ${badge.cls}">
              <img class="badge__icon" src="{% static 'imgfolder/icons/lightningflash_102700 (1) 1.svg' %}" alt="">
              <p>${badge.label}</p>
            </div>` : ``}
        </div>
        <div class="body">
          <h3 class="name"><a href="${href}" target="_blank">${name}</a></h3>
          <a class="price-link" href="${href}" target="_blank" rel="noopener">перейти к товару</a>
        </div>
        <div class="foot">
          <button class="icon-btn heart"
                  type="button"
                  title="В избранное"
                  data-fav-btn
                  data-label-add="В избранное"
                  data-label-remove="В избранном"
                  data-product-id="${id}"
                  data-product-name="${escapeAttr(card.name || '')}"
                  data-product-image="${escapeAttr(img)}"
                  data-product-url="${href}"
                  aria-pressed="false">
            <img src="{% static '/imgfolder/icons/heart_ico-cropped.svg' %}" alt="">
          </button>
          <button class="icon-btn tg-ico" title="написать" type="button" onclick="window.location.href='${href}'">
            <img src="{% static '/imgfolder/ico_contact/Arrow 63.png' %}" alt="">
          </button>
        </div>
      </div>`;
                }).join("");
            }

            function renderCards(items) {
                if (!items || !items.length) {
                    $grid.innerHTML = "";
                    $empty.style.display = "block";
                    return;
                }
                $empty.style.display = "none";
                $grid.innerHTML = renderCardsToHtml(items);
            }

            function renderFilters(groups) {
  // --- Нормализация входа ---
  groups = Array.isArray(groups) ? groups : normalizeGroups(groups);

  // --- Служебные нормализации для сопоставления названий ---
  const norm = (s) => String(s || "")
    .toLowerCase()
    .replace(/ё/g, "е")
    .replace(/\(([^)]*)\)/g, "$1")     // убираем сами скобки, оставляя содержимое
    .replace(/\s+/g, " ")              // схлопываем пробелы
    .trim();

  // Список целевого порядка (нормализованный)
  const RAW_ORDER = [
    "облицовочный кирпич",
    "клинкерный кирпич",
    "кирпич ручной формовки",
    "ригельный кирпич",
    "навесные вентилируемые системы (нвф)",
    "клинкерная плитка под нвф",
    "плитка под кирпич",
    "брусчатка",
      "кровельные материалы",
    "керамические блоки",
    "смеси",
    "газоблок"
  ];
  const ORDER = RAW_ORDER.map(norm);

  // частые синонимы/перестановки слов → приводим к эталону
  const ALIASES = new Map([
    [norm("кирпич ригельный"), norm("ригельный кирпич")],
    [norm("плитка клинкерная под нвф"), norm("клинкерная плитка под нвф")],
    [norm("клинкерная плитка для нвф"), norm("клинкерная плитка под нвф")],
    [norm("кирпич облицовочный"), norm("облицовочный кирпич")],
    [norm("ручной формовки кирпич"), norm("кирпич ручной формовки")],
  ]);

  const toKey = (label) => {
    const k = norm(label);
    return ALIASES.get(k) || k;
  };

  const orderIndex = (label) => {
    const k = toKey(label);
    const i = ORDER.indexOf(k);
    return i === -1 ? Number.POSITIVE_INFINITY : i;
  };

  // --- Поднимаем "Категория товара" (product_type) наверх ---
  groups.sort((a, b) => {
    const pa = String(a.param || a.name || a.key || "").trim();
    const pb = String(b.param || b.name || b.key || "").trim();
    if (pa === "product_type") return -1;
    if (pb === "product_type") return 1;
    return 0;
  });

  $filters.innerHTML = "";
  state.paramMap = {};

  (groups || []).forEach(group => {
    const paramName = String(group.param || group.name || group.key || group.slug || "").trim();
    if (!paramName) return;

    state.paramMap[group.key || group.name || paramName] = paramName;

    const isCategoryFilter = (paramName === "product_type");
    const displayTitle = isCategoryFilter
      ? "Категория товара"
      : (FILTER_TITLES[paramName] || group.verbose_name || group.title || group.label || group.name || group.key || paramName);

    const current = state.filters[paramName] || [];
    const wrap = document.createElement("div");

    // Категория товара всегда открыта и не сворачивается
    wrap.className = "filter-item" + (isCategoryFilter ? " open always-open" : "");
    wrap.innerHTML = `
      <div class="filter-head" role="button" tabindex="0" aria-expanded="${isCategoryFilter ? "true" : "false"}">
        <h4>${escapeHtml(displayTitle)}</h4>
        <svg class="chev" width="18" height="18" viewBox="0 0 24 24"><path d="M6 9l6 6 6-6" fill="none" stroke="#5a4a48" stroke-width="2"/></svg>
      </div>
      <div class="filter-content" style="${isCategoryFilter ? "display:block" : ""}">
        <div class="options"></div>
      </div>`;

    const options = wrap.querySelector(".options");

    // Берём значения
    let values = normalizeValues(group.values || group.options || group.items || group.choices || []);

    // Сортируем строго по нашему ORDER только для "Категория товара"
    if (isCategoryFilter) {
      // сначала — те, что нашли место в ORDER (по индексу),
      // затем — остальные, сохраняя их относительный порядок
      values = values
        .map((v, idx) => ({ v, idx, oi: orderIndex(v.label ?? v.value) }))
        .sort((a, b) => {
          if (a.oi === b.oi) return a.idx - b.idx; // стабильность для "хвоста"
          return a.oi - b.oi;
        })
        .map(x => x.v);
    }

    // Рисуем чекбоксы
    values.forEach(v => {
      const rawLabel = v.label ?? v.value;
      const val = String(v.value);
      const label = escapeHtml(rawLabel ?? val);
      const checked = current.includes(val) ? "checked" : "";
      options.insertAdjacentHTML(
        "beforeend",
        `<label class="opt">
           <input type="checkbox" data-param="${escapeAttr(paramName)}" value="${escapeAttr(val)}" ${checked}>
           <span>${label}</span>
         </label>`
      );
    });

    // Обработчики
    const head = wrap.querySelector(".filter-head");
    head.addEventListener("click", () => {
      if (isCategoryFilter) return; // не сворачиваем категорию
      const isOpen = wrap.classList.toggle("open");
      head.setAttribute("aria-expanded", String(isOpen));
    });

    options.addEventListener("change", e => {
      if (e.target && e.target.matches("input[type=checkbox]")) {
        const param = e.target.dataset.param;
        const val = e.target.value;
        const set = new Set(state.filters[param] || []);
        if (e.target.checked) set.add(val); else set.delete(val);
        state.filters[param] = Array.from(set);
        $apply.disabled = false;
        applyFiltersDebounced();
      }
    });

    $filters.appendChild(wrap);
  });

  if (!$filters.children.length) {
    $filters.innerHTML = `<div class="filter-item">
      <div class="filter-head"><h4>Фильтры недоступны</h4></div>
      <div class="filter-content" style="display:block;padding:12px 16px;color:#9a8f8d">
        Для этой категории фильтры не настроены.
      </div>
    </div>`;
  }
}



            // data loaders
            async function loadCategoryName() {
                async function loadMoreUniversal() {
                    if (isSearch) {
                        if (!searchState.hasNext || searchState.isLoading) return;
                        searchState.isLoading = true;
                        $spinner.style.display = "block";
                        try {
                            searchState.page += 1;
                            await loadProducts({append: true});
                        } finally {
                            searchState.isLoading = false;
                            $spinner.style.display = "none";
                            $loadMore.style.display = searchState.hasNext ? "inline-block" : "none";
                        }
                    } else {
                        if (!listState.hasNext || listState.isLoading) return;
                        listState.isLoading = true;
                        $spinner.style.display = "block";
                        try {
                            listState.page += 1;
                            await loadProducts({append: true});
                        } finally {
                            listState.isLoading = false;
                            $spinner.style.display = "none";
                            $loadMore.style.display = listState.hasNext ? "inline-block" : "none";
                        }
                    }
                }

// кнопка
                $loadMore.addEventListener("click", loadMoreUniversal);

// автоподгрузка при прокрутке (если поддерживается)
                if ('IntersectionObserver' in window && $sentinel) {
                    const io = new IntersectionObserver((entries) => {
                        if (entries[0].isIntersecting) loadMoreUniversal();
                    }, {root: null, rootMargin: "400px 0px 400px 0px", threshold: 0});
                    io.observe($sentinel);
                }

                if (apiSlug === "all") return;
                try {
                    const res = await fetch(urlFor(epCategoryCat, apiSlug), {credentials: "same-origin"});
                    if (!res.ok) return;
                    const data = await res.json();
                    const nm = data?.name || data?.title || toTitle(catSlug);
                    $title.textContent = nm;
                    $crumb.textContent = nm;
                } catch (_) {
                }
            }

            async function loadFilters() {
                if (isSearch) {
                    // В режиме поиска фильтры можно скрыть, чтобы не путать пользователя:
                    const panel = root.querySelector(".filters");
                    if (panel) panel.style.display = "none";
                    return;
                }
                const url = (apiSlug !== "all") ? urlFor(epFiltersCat, apiSlug) : epFiltersAll;
                if (!url) {
                    renderFilters([]);
                    return;
                }
                try {
                    const res = await fetch(url, {credentials: "same-origin"});
                    if (!res.ok) throw new Error("filters " + res.status);
                    const data = await res.json();
                    const raw = Array.isArray(data) ? data : (data.groups || data.filters || data.facets || data.data || data);
                    const groups = normalizeGroups(raw);
                    if (data && (data.name || data.category_name)) {
                        const nm = data.name || data.category_name;
                        $title.textContent = nm;
                        $crumb.textContent = nm;
                    }
                    renderFilters(groups);
                } catch (e) {
                    console.warn("filters load error:", e);
                    renderFilters([]);
                }
            }

            async function loadProducts({append = false} = {}) {
                if (!append) renderSkeletonCards();

                try {
                    let items = [];
                    let url = "";
                    if (isSearch) {
                        // поиск
                        if (!append) searchState.page = 1;
                        const qstr = buildQuery(true); // ?q=...&sort=...
                        const sep = qstr ? "&" : "?";
                        url = epSearchProducts + qstr + `${sep}page=${searchState.page}&per_page=${searchState.perPage}`;
                    } else {
                        // обычный каталог
                        if (!append) listState.page = 1;
                        const base = (apiSlug !== "all") ? urlFor(epProductsCat, apiSlug) : epProductsAll;
                        const qstr = buildQuery(false);
                        const sep = qstr ? "&" : "?";
                        url = base + qstr + `${sep}page=${listState.page}&per_page=${listState.perPage}`;
                    }

                    const res = await fetch(url, {credentials: "same-origin"});
                    if (!res.ok) throw new Error("products " + res.status);
                    const data = await res.json();

                    const pageItems = Array.isArray(data) ? data : (data.items || data.results || []);
                    items = pageItems;

                    // клиентская сортировка по имени (если выбрана)
                    if (state.sort === "name_asc" || state.sort === "name_desc") {
                        items = items.slice().sort((a, b) => (a.name || "").localeCompare(b.name || "", "ru", {sensitivity: "base"}));
                        if (state.sort === "name_desc") items.reverse();
                    }

                    // отрисовка
                    if (append) {
                        appendCards(items);
                    } else {
                        renderCards(items);
                    }

                    // переключатели подгрузки
                    if (isSearch) {
                        searchState.hasNext = !!(data && (data.has_next || (data.page < data.pages)));
                        $loadWrap.style.display = "block";
                        $loadMore.style.display = searchState.hasNext ? "inline-block" : "none";
                    } else {
                        listState.hasNext = !!(data && (data.has_next || (data.page < data.pages)));
                        $loadWrap.style.display = "block";
                        $loadMore.style.display = listState.hasNext ? "inline-block" : "none";
                    }

                } catch (e) {
                    console.error("products load error:", e);
                    if (!append) renderCards([]);
                }
            }


            function buildQueryForAllSafe() {
                // теперь полная строка запроса, как для категорий
                return buildQuery(false);
            }

            // actions
            async function applyFiltersNow() {
                pushUrl();
                await loadProducts();
            }

            $apply.addEventListener("click", applyFiltersNow);

            $reset.addEventListener("click", async () => {
                state.filters = {};
                state.sort = "default";
                $sort.value = "default";
                pushUrl();
                await loadFilters();
                await loadProducts();
            });

            $sort.addEventListener("change", async () => {
                state.sort = $sort.value;
                pushUrl();
                await loadProducts();
            });

            // init
            (async function init() {
                await loadCategoryName();
                await loadFilters();
                await loadProducts();
            })();

            async function loadMoreSearch() {
                if (!isSearch || !searchState.hasNext || searchState.isLoading) return;
                searchState.isLoading = true;
                $spinner.style.display = "block";
                try {
                    searchState.page += 1;
                    await loadProducts({append: true});
                } finally {
                    searchState.isLoading = false;
                    $spinner.style.display = "none";
                    $loadMore.style.display = searchState.hasNext ? "inline-block" : "none";
                }
            }

            if (isSearch) {
                // кнопка
                $loadMore.addEventListener("click", loadMoreSearch);

                // автоподгрузка внизу страницы
                if ('IntersectionObserver' in window && $sentinel) {
                    const io = new IntersectionObserver((entries) => {
                        if (entries[0].isIntersecting) {
                            loadMoreSearch();
                        }
                    }, {root: null, rootMargin: "400px 0px 400px 0px", threshold: 0});
                    io.observe($sentinel);
                }
            }
        })();
    </script>

{% endblock %}
